<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Cosmic Timeline – Event‑by‑Event Journey</title>
<style>
/* === same base styles, added controls for next/prev/pause === */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  background: #000;
  color: #fff;
  font-family: 'Courier New', monospace;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  overflow: auto;
}

#container {
  position: relative;
  margin: 20px;
}

#controls {
  position: absolute;
  top: -45px;
  left: 0;
  z-index: 10;
  background: rgba(0, 0, 0, 0.9);
  padding: 8px 12px;
  border: 1px solid #333;
  border-radius: 4px;
  display: flex;
  align-items: center;
  gap: 12px;
  flex-wrap: wrap;
}

#controls input[type="date"] {
  font-size: 12px;
  padding: 4px;
  background: #111;
  color: #fff;
  border: 1px solid #555;
  border-radius: 3px;
}

#controls button {
  font-size: 12px;
  padding: 4px 10px;
  background: #222;
  color: #0ff;
  border: 1px solid #0ff;
  border-radius: 3px;
  cursor: pointer;
  font-family: 'Courier New', monospace;
  transition: 0.2s;
}

#controls button:hover {
  background: #0ff;
  color: #000;
}

/* special animation buttons */
#playPauseBtn {
  background: #2a2a2a;
  color: #ffaa00;
  border-color: #ffaa00;
  font-weight: bold;
  min-width: 60px;
}
#playPauseBtn:hover {
  background: #ffaa00;
  color: #000;
}

#prevBtn, #nextBtn {
  background: #333;
  color: #fff;
  border-color: #888;
}
#prevBtn:hover, #nextBtn:hover {
  background: #888;
  color: #000;
}

.mode-switch {
  display: flex;
  align-items: center;
  gap: 6px;
}

.mode-label {
  font-size: 10px;
  color: #888;
}

.switch {
  position: relative;
  display: inline-block;
  width: 40px;
  height: 18px;
}

.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #555;
  transition: .3s;
  border-radius: 18px;
}

.slider:before {
  position: absolute;
  content: "";
  height: 12px;
  width: 12px;
  left: 3px;
  bottom: 3px;
  background-color: white;
  transition: .3s;
  border-radius: 50%;
}

input:checked + .slider {
  background-color: #f00;
}

input:checked + .slider:before {
  transform: translateX(22px);
}

.mode-text {
  font-size: 10px;
  color: #0f0;
  font-weight: bold;
  min-width: 65px;
}

canvas {
  border: 2px solid #333;
  display: block;
  background-size: cover;
  background-position: center;
}

#timeSync {
  position: absolute;
  bottom: -35px;
  right: 0;
  background: rgba(0, 0, 0, 0.9);
  padding: 6px 10px;
  border: 1px solid #333;
  border-radius: 3px;
  font-size: 10px;
  color: #888;
}

#info {
  position: absolute;
  bottom: -35px;
  left: 0;
  font-size: 10px;
  background: rgba(0, 0, 0, 0.9);
  padding: 6px 10px;
  border: 1px solid #333;
  border-radius: 3px;
}

.status-dot {
  display: inline-block;
  width: 6px;
  height: 6px;
  border-radius: 50%;
  margin-right: 4px;
}

.status-synced {
  background: #0f0;
  box-shadow: 0 0 3px #0f0;
  animation: pulse 2s infinite;
}

.status-syncing {
  background: #ff0;
  box-shadow: 0 0 3px #ff0;
}

.status-offline {
  background: #f00;
  box-shadow: 0 0 3px #f00;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

/* current year display (bottom left) */
#currentYearDisplay {
  position: absolute;
  bottom: -60px;
  left: 0;
  background: rgba(0,0,0,0.9);
  padding: 6px 12px;
  border: 1px solid #ffaa00;
  border-radius: 20px;
  color: #ffaa00;
  font-size: 14px;
  font-weight: bold;
  letter-spacing: 1px;
  z-index: 15;
}
</style>
</head>
<body>

<div id="container">
  <div id="controls">
    <label>Birth Date: <input type="date" id="birthDate"></label>
    <button id="resetZoom">Reset View</button>
    
    <!-- NEW: Prev / Next / PlayPause -->
    <button id="prevBtn" title="Previous event">◀ Prev</button>
    <button id="playPauseBtn" title="Start/stop auto journey">▶ Play</button>
    <button id="nextBtn" title="Next event">Next ▶</button>

    <div class="mode-switch">
      <span class="mode-label">Mode:</span>
      <label class="switch">
        <input type="checkbox" id="modeToggle">
        <span class="slider"></span>
      </label>
      <span class="mode-text" id="modeText">Linear</span>
    </div>
  </div>

  <canvas id="cosmicCanvas" width="800" height="480"></canvas>

  <div id="timeSync">
    <span class="status-dot status-syncing" id="statusDot"></span>
    <span id="syncStatus">Syncing...</span>
  </div>

  <div id="info">
    Drag to pan • Scroll to zoom • Zoom: <span id="zoomLevel">1.00x</span>
  </div>

  <!-- Current year/event display -->
  <div id="currentYearDisplay">—</div>
</div>

<!-- Background Music -->
<audio id="bgMusic" loop>
  <source src="space.mp3" type="audio/mpeg">
</audio>

<script>
// =============================
// Canvas Setup
// =============================
const canvas = document.getElementById("cosmicCanvas");
const ctx = canvas.getContext("2d");

const WIDTH = 800;
const HEIGHT = 480;

// Load background image
const bgImage = new Image();
bgImage.src = "space.jpg";
bgImage.onerror = () => {
  console.log("Background image not found, using black background");
};

// =============================
// Timeline Mode (Linear / Log)
// =============================
let isLinearMode = true;
const modeToggle = document.getElementById("modeToggle");
const modeText = document.getElementById("modeText");

modeToggle.addEventListener("change", () => {
  isLinearMode = !modeToggle.checked;
  modeText.textContent = isLinearMode ? "Linear" : "Logarithmic";
  modeText.style.color = isLinearMode ? "#0f0" : "#f00";
});
modeText.style.color = "#0f0";

// =============================
// Background Music
// =============================
const bgMusic = document.getElementById("bgMusic");
bgMusic.volume = 0.3;

function startMusic() {
  bgMusic.play().catch(err => {
    console.log("Autoplay blocked, waiting for user interaction");
    document.addEventListener('click', () => {
      bgMusic.play().catch(e => console.log("Music play failed:", e));
    }, { once: true });
  });
}

// =============================
// Time Synchronization
// =============================
let timeOffset = 0;
let isTimeSynced = false;
let universeStartTime = null;
let serverTimeBase = null;
let localTimeBase = null;

async function syncWithWorldTime() {
  try {
    const statusDot = document.getElementById('statusDot');
    const syncStatus = document.getElementById('syncStatus');
    
    statusDot.className = 'status-dot status-syncing';
    syncStatus.textContent = 'Syncing...';
    
    const response = await fetch('https://worldtimeapi.org/api/timezone/Etc/UTC');
    const data = await response.json();
    
    serverTimeBase = data.unixtime * 1000;
    localTimeBase = Date.now();
    timeOffset = serverTimeBase - localTimeBase;
    
    const UNIVERSE_AGE_MS = 13.787e9 * 365.25 * 24 * 60 * 60 * 1000;
    universeStartTime = serverTimeBase - UNIVERSE_AGE_MS;
    
    isTimeSynced = true;
    statusDot.className = 'status-dot status-synced';
    syncStatus.textContent = `Synced (UTC)`;
    
    startMusic();
    
    console.log('Time synced successfully');
    
  } catch (error) {
    console.error('Time sync failed:', error);
    const statusDot = document.getElementById('statusDot');
    const syncStatus = document.getElementById('syncStatus');
    statusDot.className = 'status-dot status-offline';
    syncStatus.textContent = 'Local time';
    
    localTimeBase = Date.now();
    serverTimeBase = localTimeBase;
    timeOffset = 0;
    
    const UNIVERSE_AGE_MS = 13.787e9 * 365.25 * 24 * 60 * 60 * 1000;
    universeStartTime = localTimeBase - UNIVERSE_AGE_MS;
    isTimeSynced = false;
    
    startMusic();
  }
}

function getCurrentTime() {
  return Date.now() + timeOffset;
}

syncWithWorldTime();
setInterval(syncWithWorldTime, 60 * 60 * 1000);

// =============================
// Pan & Zoom (zoom no longer stops animation)
// =============================
let offsetX = 0;
let offsetY = 0;
let zoom = 1.0;
let isDragging = false;
let dragStart = {x: 0, y: 0};
let dragOffsetStart = {x: 0, y: 0};

canvas.addEventListener("mousedown", e => {
  isDragging = true;
  dragStart = {x: e.offsetX, y: e.offsetY};
  dragOffsetStart = {x: offsetX, y: offsetY};
  // dragging pauses auto animation
  if (autoActive) pauseAnimation();
});

canvas.addEventListener("mouseup", () => isDragging = false);
canvas.addEventListener("mouseleave", () => isDragging = false);

canvas.addEventListener("mousemove", e => {
  if (isDragging) {
    offsetX = dragOffsetStart.x + (e.offsetX - dragStart.x) / zoom;
    offsetY = dragOffsetStart.y + (e.offsetY - dragStart.y) / zoom;
  }
});

canvas.addEventListener("wheel", e => {
  e.preventDefault();
  const scaleFactor = 1.1;
  const mouseX = e.offsetX;
  const mouseY = e.offsetY;
  const worldX = (mouseX / zoom - offsetX);
  const worldY = (mouseY / zoom - offsetY);
  zoom *= e.deltaY < 0 ? scaleFactor : 1 / scaleFactor;
  offsetX = mouseX / zoom - worldX;
  offsetY = mouseY / zoom - worldY;
  // zoom does NOT stop animation (as requested)
});

document.getElementById('resetZoom').addEventListener('click', () => {
  zoom = 1.0;
  offsetX = 0;
  offsetY = 0;
  // reset view does NOT stop animation (optional, but we'll keep it non‑stopping)
});

// =============================
// Animation State (event‑by‑event)
// =============================
let autoActive = false;          // whether auto‑move is on
let moving = false;              // currently moving between events
let pauseTimer = 0;              // remaining pause time in ms
const PAUSE_DURATION = 2000;     // 2 seconds at each event
const MOVE_DURATION = 4000;      // 4 seconds to move between events (slower)

let currentEventIndex = 0;        // index of the event we are at (or moving from)
let targetEventIndex = 1;         // index we are moving to (if moving)
let moveProgress = 0;             // 0..1

let timelinePoints = [];          // will be populated after constants

// Buttons
const playPauseBtn = document.getElementById('playPauseBtn');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const yearDisplay = document.getElementById('currentYearDisplay');

playPauseBtn.addEventListener('click', toggleAuto);
prevBtn.addEventListener('click', previousEvent);
nextBtn.addEventListener('click', nextEvent);

function toggleAuto() {
  if (autoActive) {
    pauseAnimation();
  } else {
    startAnimation();
  }
}

function pauseAnimation() {
  autoActive = false;
  moving = false;
  playPauseBtn.textContent = '▶ Play';
}

function startAnimation() {
  if (timelinePoints.length === 0) return;
  autoActive = true;
  playPauseBtn.textContent = '⏸ Pause';
  // if we are at the last event, restart from beginning? or just do nothing
  if (currentEventIndex >= timelinePoints.length - 1) {
    // go to first
    currentEventIndex = 0;
    targetEventIndex = 1;
    moveProgress = 0;
    moving = true;
  } else if (!moving && currentEventIndex < timelinePoints.length - 1) {
    // start moving to next
    targetEventIndex = currentEventIndex + 1;
    moveProgress = 0;
    moving = true;
  }
}

function stopAnimation() {
  autoActive = false;
  moving = false;
  playPauseBtn.textContent = '▶ Play';
}

// Next/prev logic
function nextEvent() {
  if (timelinePoints.length === 0) return;
  // stop auto if running
  if (autoActive) stopAnimation();
  
  if (currentEventIndex < timelinePoints.length - 1) {
    currentEventIndex++;
    targetEventIndex = Math.min(currentEventIndex + 1, timelinePoints.length - 1);
    moveProgress = 0;
    moving = false; // not moving, just jump
    updateCameraToCurrent();
  }
}

function previousEvent() {
  if (timelinePoints.length === 0) return;
  if (autoActive) stopAnimation();
  
  if (currentEventIndex > 0) {
    currentEventIndex--;
    targetEventIndex = currentEventIndex + 1;
    moveProgress = 0;
    moving = false;
    updateCameraToCurrent();
  }
}

function updateCameraToCurrent() {
  if (!timelinePoints.length) return;
  const pt = timelinePoints[currentEventIndex];
  // center camera on this point
  const worldX = pt.worldX;
  const worldY = pt.worldY;
  offsetX = (WIDTH / 2) / zoom - worldX;
  offsetY = (HEIGHT / 2) / zoom - worldY;
}

// =============================
// Constants & Helpers
// =============================
const UNIVERSE_AGE_YEARS = 13.787e9;
const SECONDS_PER_YEAR = 365.25 * 24 * 60 * 60;
const BIG_BANG_SECONDS_AGO = UNIVERSE_AGE_YEARS * SECONDS_PER_YEAR;
const DOT_RADIUS = 2.5;

// =============================
// User Birth Date
// =============================
let birthDate = null;

document.getElementById("birthDate").addEventListener("change", e => {
  birthDate = new Date(e.target.value);
});

// =============================
// Historical Events (let for updates)
// =============================
let EVENTS = [
  { name: "AI Revolution", date: new Date("2022-11-30"), color: "#9370DB" },
  { name: "Social Media Age", date: new Date("2004-02-04"), color: "#DA70D6" },
  { name: "Smartphone Era", date: new Date("2007-06-29"), color: "#FF69B4" },
  { name: "World Wide Web", date: new Date("1991-08-06"), color: "#00CED1" },
  { name: "Internet Public", date: new Date("1983-01-01"), color: "#20B2AA" },
  { name: "Personal Computer", date: new Date("1975-01-01"), color: "#5F9EA0" },
  { name: "Microprocessor", date: new Date("1971-11-15"), color: "#4682B4" },
  { name: "Moon Landing", date: new Date("1969-07-20"), color: "#C0C0C0" },
  { name: "Space Age", date: new Date("1957-10-04"), color: "#191970" },
  { name: "DNA Structure", date: new Date("1953-04-25"), color: "#9ACD32" },
  { name: "Transistor", date: new Date("1947-12-16"), color: "#FFD700" },
  { name: "Nuclear Age", date: new Date("1945-07-16"), color: "#FF6347" },
  { name: "Television", date: new Date("1927-01-01"), color: "#4169E1" },
  { name: "Penicillin", date: new Date("1928-01-01"), color: "#98FB98" },
  { name: "Assembly Line", date: new Date("1913-01-01"), color: "#696969" },
  { name: "Airplane", date: new Date("1903-12-17"), color: "#87CEFA" },
  { name: "Radio", date: new Date("1895-01-01"), color: "#FF8C00" },
  { name: "Light Bulb", date: new Date("1879-01-01"), color: "#FFFF00" },
  { name: "Telegraph", date: new Date("1837-01-01"), color: "#BDB76B" },
  { name: "Photography", date: new Date("1826-01-01"), color: "#A9A9A9" },
  { name: "Steam Engine", date: new Date("1776-01-01"), color: "#778899" },
  { name: "Industrial Revolution", date: new Date("1760-01-01"), color: "#696969" },
  { name: "Scientific Revolution", yearsAgo: 450, color: "#9370DB" },
  { name: "Renaissance", yearsAgo: 600, color: "#DEB887" },
  { name: "Columbus Americas", date: new Date("1492-10-12"), color: "#6495ED" },
  { name: "Printing Press", date: new Date("1440-01-01"), color: "#4B0082" },
  { name: "Roman Empire", yearsAgo: 2000, color: "#CD5C5C" },
  { name: "Ancient Greece", yearsAgo: 2500, color: "#B0C4DE" },
  { name: "Iron Age", yearsAgo: 3200, color: "#708090" },
  { name: "Pyramids", yearsAgo: 4500, color: "#DAA520" },
  { name: "Writing", yearsAgo: 5200, color: "#87CEEB" },
  { name: "Bronze Age", yearsAgo: 5300, color: "#CD7F32" },
  { name: "First Cities", yearsAgo: 9000, color: "#B8860B" },
  { name: "Agriculture", yearsAgo: 12000, color: "#90EE90" },
  { name: "Cave Art", yearsAgo: 40000, color: "#DEB887" },
  { name: "Homo Sapiens", yearsAgo: 300000, color: "#FFE4B5" },
  { name: "Fire Control", yearsAgo: 1e6, color: "#FF4500" },
  { name: "Stone Tools", yearsAgo: 3.3e6, color: "#A9A9A9" },
  { name: "First Hominids", yearsAgo: 6e6, color: "#F4A460" },
  { name: "First Apes", yearsAgo: 20e6, color: "#CD853F" },
  { name: "First Primates", yearsAgo: 55e6, color: "#DDA0DD" },
  { name: "Dinosaurs Extinct", yearsAgo: 66e6, color: "#DC143C" },
  { name: "First Birds", yearsAgo: 150e6, color: "#87CEEB" },
  { name: "First Mammals", yearsAgo: 225e6, color: "#D2691E" },
  { name: "Dinosaurs Appear", yearsAgo: 230e6, color: "#8B4513" },
  { name: "First Reptiles", yearsAgo: 320e6, color: "#556B2F" },
  { name: "First Amphibians", yearsAgo: 370e6, color: "#8FBC8F" },
  { name: "Plants on Land", yearsAgo: 470e6, color: "#228B22" },
  { name: "First Fish", yearsAgo: 530e6, color: "#1E90FF" },
  { name: "Cambrian Explosion", yearsAgo: 541e6, color: "#FF1493" },
  { name: "Multicellular Life", yearsAgo: 600e6, color: "#FF69B4" },
  { name: "Oxygen Atmosphere", yearsAgo: 2.4e9, color: "#00CED1" },
  { name: "Life Begins", yearsAgo: 3.8e9, color: "#32CD32" },
  { name: "Earth Forms", yearsAgo: 4.54e9, color: "#4169E1" },
  { name: "Solar System", yearsAgo: 4.6e9, color: "#FFA500" },
  { name: "Milky Way", yearsAgo: 13.5e9, color: "#9370DB" },
  { name: "First Stars", yearsAgo: 13.6e9, color: "#FFD700" }
];

// Helper: seconds ago for an event
function calculateSecondsAgo(event) {
  const now = getCurrentTime();
  if (event.yearsAgo !== undefined) {
    return event.yearsAgo * SECONDS_PER_YEAR;
  } else if (event.date) {
    return (now - event.date.getTime()) / 1000;
  }
  return 0;
}

// =============================
// Build sorted timeline (including Big Bang and NOW)
// =============================
function buildTimelinePoints() {
  const points = [];
  
  // Big Bang (virtual)
  points.push({
    name: "Big Bang",
    yearsAgo: UNIVERSE_AGE_YEARS,
    color: "#FFD700",
    worldX: null, // will be filled after we have start/end
    worldY: null
  });
  
  // Sort events by years ago (oldest first)
  const eventsWithYears = EVENTS.map(e => {
    const secondsAgo = calculateSecondsAgo(e);
    const yearsAgo = secondsAgo / SECONDS_PER_YEAR;
    return {
      name: e.name,
      yearsAgo: yearsAgo,
      color: e.color || "#888",
    };
  });
  eventsWithYears.sort((a,b) => b.yearsAgo - a.yearsAgo);
  
  eventsWithYears.forEach(e => points.push({
    name: e.name,
    yearsAgo: e.yearsAgo,
    color: e.color,
    worldX: null, worldY: null
  }));
  
  // NOW (virtual)
  points.push({
    name: "NOW",
    yearsAgo: 0,
    color: "#FF0000",
    worldX: null, worldY: null
  });
  
  return points;
}

// =============================
// Scale functions (world coordinate mapping)
// =============================
function linearScale(secondsAgo, maxSecondsAgo) {
  return secondsAgo / maxSecondsAgo;
}

function logScale(secondsAgo, maxSecondsAgo) {
  const logPos = Math.log10(secondsAgo + 1);
  const logMax = Math.log10(maxSecondsAgo + 1);
  return logPos / logMax;
}

function getScale(secondsAgo, maxSecondsAgo) {
  return isLinearMode ? linearScale(secondsAgo, maxSecondsAgo) : logScale(secondsAgo, maxSecondsAgo);
}

// =============================
// Canvas transforms
// =============================
function toCanvasX(worldX) { return (worldX + offsetX) * zoom; }
function toCanvasY(worldY) { return (worldY + offsetY) * zoom; }

// =============================
// Formatting
// =============================
function formatNumber(n) {
  return n.toLocaleString('en-US', { maximumFractionDigits: 0 });
}

// =============================
// Draw Loop (with event‑by‑event animation)
// =============================
let lastTimestamp = 0;

function draw(now) {
  try {
    // Update animation timers
    if (autoActive && timelinePoints.length > 0) {
      if (moving) {
        // continue moving
        const elapsed = Math.min(now - lastTimestamp, 100); // safety cap
        moveProgress += elapsed / MOVE_DURATION;
        if (moveProgress >= 1) {
          moveProgress = 0;
          moving = false;
          currentEventIndex = targetEventIndex;
          // if not at end, start pause
          if (currentEventIndex < timelinePoints.length - 1) {
            pauseTimer = PAUSE_DURATION;
          } else {
            // reached NOW, stop auto
            stopAnimation();
          }
        }
      } else if (pauseTimer > 0) {
        pauseTimer -= (now - lastTimestamp);
        if (pauseTimer <= 0) {
          pauseTimer = 0;
          // move to next
          if (currentEventIndex < timelinePoints.length - 1) {
            targetEventIndex = currentEventIndex + 1;
            moveProgress = 0;
            moving = true;
          } else {
            stopAnimation();
          }
        }
      }
    }
    
    // Update camera position based on current state
    if (timelinePoints.length > 0) {
      let targetWorldX, targetWorldY;
      if (moving) {
        // interpolate between currentEventIndex and targetEventIndex
        const p1 = timelinePoints[currentEventIndex];
        const p2 = timelinePoints[targetEventIndex];
        const t = moveProgress;
        targetWorldX = p1.worldX * (1 - t) + p2.worldX * t;
        targetWorldY = p1.worldY * (1 - t) + p2.worldY * t;
      } else {
        // paused at currentEventIndex
        const pt = timelinePoints[currentEventIndex];
        targetWorldX = pt.worldX;
        targetWorldY = pt.worldY;
      }
      
      // Center camera on target (unless user is dragging)
      if (!isDragging) {
        offsetX = (WIDTH / 2) / zoom - targetWorldX;
        offsetY = (HEIGHT / 2) / zoom - targetWorldY;
      }
      
      // Update year display
      if (!moving && currentEventIndex < timelinePoints.length) {
        const pt = timelinePoints[currentEventIndex];
        const yearsAgo = pt.yearsAgo;
        if (yearsAgo !== undefined) {
          yearDisplay.textContent = `${pt.name}: ${formatNumber(yearsAgo)} years ago`;
        } else {
          yearDisplay.textContent = pt.name;
        }
      } else if (moving) {
        // interpolate years
        const p1 = timelinePoints[currentEventIndex];
        const p2 = timelinePoints[targetEventIndex];
        const t = moveProgress;
        const yearsAgo = p1.yearsAgo * (1 - t) + p2.yearsAgo * t;
        yearDisplay.textContent = `→ ${formatNumber(yearsAgo)} years ago`;
      }
    }
    
    // Draw background
    if (bgImage.complete && bgImage.naturalWidth > 0) {
      ctx.drawImage(bgImage, 0, 0, WIDTH, HEIGHT);
    } else {
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
    }
    
    // Update zoom display
    document.getElementById('zoomLevel').textContent = zoom.toFixed(2) + 'x';
    
    if (!universeStartTime) {
      ctx.fillStyle = "white";
      ctx.font = "14px monospace";
      ctx.fillText("Initializing...", WIDTH / 2 - 50, HEIGHT / 2);
      requestAnimationFrame(draw);
      return;
    }
    
    const currentTime = getCurrentTime();
    
    // Big Bang counters
    const totalSeconds = Math.floor((currentTime - universeStartTime) / 1000);
    const yearsSinceBigBang = Math.floor(totalSeconds / SECONDS_PER_YEAR);
    
    ctx.fillStyle = "#FFD700";
    ctx.font = "14px monospace";
    ctx.fillText("Big Bang: " + formatNumber(yearsSinceBigBang) + " years", 10, 25);
    ctx.fillStyle = "#FFF";
    ctx.font = "12px monospace";
    ctx.fillText(formatNumber(totalSeconds) + " seconds total", 10, 45);
    
    // Timeline line from top‑left (Big Bang) to bottom‑right (NOW)
    const padding = 100;
    const start = {x: padding, y: padding};
    const end = {x: WIDTH - padding, y: HEIGHT - padding};
    
    // Precompute world coordinates for each timeline point
    if (timelinePoints.length === 0) {
      timelinePoints = buildTimelinePoints();
    }
    // update world positions based on current scale
    timelinePoints.forEach(pt => {
      const frac = getScale(pt.yearsAgo * SECONDS_PER_YEAR, BIG_BANG_SECONDS_AGO);
      const fracPos = 1 - frac; // 0 = Big Bang, 1 = NOW
      pt.worldX = start.x + (end.x - start.x) * fracPos;
      pt.worldY = start.y + (end.y - start.y) * fracPos;
    });
    
    ctx.strokeStyle = "#888";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(toCanvasX(start.x), toCanvasY(start.y));
    ctx.lineTo(toCanvasX(end.x), toCanvasY(end.y));
    ctx.stroke();
    
    // Draw all events (including virtual ones)
    timelinePoints.forEach((pt, idx) => {
      const x = pt.worldX;
      const y = pt.worldY;
      
      ctx.fillStyle = pt.color;
      ctx.beginPath();
      ctx.arc(toCanvasX(x), toCanvasY(y), idx === 0 || idx === timelinePoints.length-1 ? DOT_RADIUS*2.5 : DOT_RADIUS*1.5, 0, Math.PI*2);
      ctx.fill();
      
      ctx.fillStyle = "#FFF";
      ctx.font = idx === 0 || idx === timelinePoints.length-1 ? "13px monospace" : "11px monospace";
      ctx.fillText(pt.name, toCanvasX(x) + 8, toCanvasY(y));
      
      ctx.font = "9px monospace";
      ctx.fillStyle = "#DDD";
      if (pt.yearsAgo !== undefined) {
        ctx.fillText(formatNumber(pt.yearsAgo) + " y", toCanvasX(x) + 8, toCanvasY(y) + 13);
      }
    });
    
    // User's birth (if set)
    if (birthDate) {
      const secondsAgo = (currentTime - birthDate.getTime()) / 1000;
      const yearsAgo = secondsAgo / SECONDS_PER_YEAR;
      const frac = getScale(secondsAgo, BIG_BANG_SECONDS_AGO);
      const fracPos = 1 - frac;
      const x = start.x + (end.x - start.x) * fracPos;
      const y = start.y + (end.y - start.y) * fracPos;
      
      ctx.fillStyle = "#00FFFF";
      ctx.beginPath();
      ctx.arc(toCanvasX(x), toCanvasY(y), DOT_RADIUS * 2, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = "#00FFFF";
      ctx.font = "11px monospace";
      ctx.fillText("YOU", toCanvasX(x) + 8, toCanvasY(y));
      
      ctx.font = "9px monospace";
      ctx.fillStyle = "#AAF0FF";
      ctx.fillText(formatNumber(yearsAgo) + " y", toCanvasX(x) + 8, toCanvasY(y) + 13);
      ctx.fillText(formatNumber(Math.floor(secondsAgo)) + " s", toCanvasX(x) + 8, toCanvasY(y) + 23);
    }
    
    // Live timestamp
    ctx.fillStyle = "#888";
    ctx.font = "10px monospace";
    ctx.fillText(new Date(currentTime).toISOString().substr(11,8), WIDTH - 100, HEIGHT - 10);
    
  } catch (e) {
    console.error("Draw error:", e);
  }
  
  lastTimestamp = now;
  requestAnimationFrame(draw);
}

// Start drawing
requestAnimationFrame(draw);
</script>

</body>
</html>